import React, { useState } from "react";
import "../AddBooksForm.css";
import { db } from "../config/firebase";
import {
  getDocs,
  collection,
  addDoc,
  deleteDoc,
  updateDoc,
  doc,
  setDoc,
  writeBatch,
} from "firebase/firestore";
import { ActionCodeOperation } from "firebase/auth";

//same thing as Library
type ChapterQuestions = {
  chapterId: string;
  chapterNumber: number;
  questions: string[];
  answers: string[];
};

type Book = {
  id: string;
  title: string;
  description?: string;
  chapters?: ChapterQuestions[];
  imageUrl?: string;
};

type AddBookFormProps = {
  book: Book;
  onSave: (bookData: Book) => void;
  onClose: () => void;
};

const AddBooksForm: React.FC<AddBookFormProps> = ({
  book,
  onSave,
  onClose,
}) => {
  const [title, setTitle] = useState(book.title); //this is the current title of the book
  const [description, setDescription] = useState(book.description || ""); //this is the description of book
  const [imageUrl, setImageUrl] = useState(book.imageUrl || ""); //this is urlImage
  const [chapters, setChapters] = useState(
    book.chapters || [
      {
        //these are chapters
        chapterId: Date.now().toString(),
        chapterNumber: 1,
        questions: ["Question"],
        answers: ["Answer"],
      },
    ]
  );

  const [deleteChapters, doDeleteChapters] = useState<string[]>([]); //store ids
  const [numberOfChapters, setNumberOfChapters] = useState(
    chapters.length || 1
  ); //number of chapters
  const [activeChapter, setExactChapter] = useState(1); //which on you're on
  //when you submit, save whatever's in useState to array and database
  const handleSubmit = async (event: React.FormEvent) => {
    event.preventDefault();

    // Check if the ID is a temporary one
    if (book.id.startsWith('temp-')) {
      // This is a new book, so add it to Firestore
      try {
        const docRef = await addDoc(collection(db, "books"), {
          title: title,
          description: description,
          imageUrl: imageUrl,
          // Handle chapters as needed
        });
        console.log("New document added with ID: ", docRef.id);
        // Update the book's ID with the one generated by Firestore
        onSave({ ...book, id: docRef.id, title, description, imageUrl, chapters });
      } catch (error) {
        console.error("Error adding document: ", error);
      }
    } else {
      // Existing book, update it
      try {
        await updateDoc(doc(db, "books", book.id), {
          title: title,
          description: description,
          imageUrl: imageUrl,
          // Handle chapters as needed
        });
        console.log("Document updated with ID: ", book.id);
        onSave({ ...book, title, description, imageUrl, chapters }); // Pass the updated data back up
      } catch (error) {
        console.error("Error updating document: ", error);
      }
    }

    onClose(); 
  };

  const handleChapterQuestionChange = (
    chapterIndex: number,
    question: string,
    questionIndex: number
  ) => {
    const newChapters = [...chapters];
    // console.log(activeChapter);
    // console.log(chapterIndex);
    // console.log(newChapters);
    newChapters[chapterIndex].questions[questionIndex] = question;
    setChapters(newChapters);
  };

  const handleChapterAnswerChange = (
    chapterIndex: number,
    answer: string,
    questionIndex: number
  ) => {
    const newChapters = [...chapters];
    newChapters[chapterIndex].answers[questionIndex] = answer;
    setChapters(newChapters);
  };

  const handleNumberOfChaptersChange = async (count: number) => {
    setNumberOfChapters(count);
    const newChapters = chapters ? [...chapters] : [];
    const diff = count - newChapters.length;
    const currLength = newChapters.length;
    const append = Date.now().toString();

    // Add the new chapter to the end of the new array
    if (diff > 0) {
      for (let i = 0; i < diff; i++) {
        const append = Date.now().toString() + i;
        const newChapterNumber = currLength + i + 1;

        newChapters.push({
          chapterId: append,
          chapterNumber: newChapterNumber,
          questions: ["Question"],
          answers: ["Answer"],
        });
      }

      // Update the state with the new chapters array
    } else if (diff < 0) {
      const chaptersToRemove = newChapters.slice(count);
      newChapters.splice(count);

      const toRemove = [];
      for (const chapter of chaptersToRemove) {
        toRemove.push(chapter.chapterId);
      }
      doDeleteChapters([...deleteChapters, ...toRemove]);

      setExactChapter(count);
    }
    setChapters(newChapters);
  };

  const addQuestionToChapter = async (chapterIndex: number) => {
    // Make a shallow copy of the chapters array
    const newChapters = [...chapters];

    // Check if the chapter has a questions array, and if not, initialize it
    const updatedQuestions = [
      ...newChapters[chapterIndex].questions,
      "Question",
    ];
    const updatedAnswers = [...newChapters[chapterIndex].answers, "Answer"];

    // Update the local copy of the chapters array with the new question and answer
    newChapters[chapterIndex] = {
      ...newChapters[chapterIndex],
      questions: updatedQuestions,
      answers: updatedAnswers,
    };

    // Define the Firestore document reference for the specific chapter

    setChapters(newChapters);
  };

  const deleteQuestion = async (
    chapterIndex: number,
    questionIndex: number
  ) => {
    const newChapters = chapters.map((chapter, index) => {
      if (index === chapterIndex) {
        // Copy the chapter and modify its questions array
        return {
          ...chapter,
          questions: chapter.questions.filter(
            (_, qIndex) => qIndex !== questionIndex
          ),
          answers: chapter.answers.filter(
            (_, aIndex) => aIndex !== questionIndex
          ),
        };
      }
      return chapter;
    });

    setChapters(newChapters);
  };

  let activeChapterContent = chapters.find(
    (chapter) => chapter.chapterNumber === activeChapter
  );
  return (
    <div className="add-books-form">
      <h1>Edit Book</h1>
      <form onSubmit={handleSubmit}>
        <label>
          Book Title:
          <input
            type="text"
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            className="form-input"
            placeholder="Untitled"
          />
        </label>
        <label>
          Book Image URL:
          <input
            type="text"
            value={imageUrl}
            onChange={(e) => setImageUrl(e.target.value)}
            className="form-input"
          />
        </label>
        <label>
          Book Description:
          <textarea
            value={description}
            onChange={(e) => setDescription(e.target.value)}
            className="form-textarea"
            onKeyDown={(e) => {
              if (e.key === "Enter") e.preventDefault();
            }}
          />
        </label>
        <label>
          Number of Chapters:
          <input //how many
            type="number"
            value={numberOfChapters}
            onChange={(e) =>
              handleNumberOfChaptersChange(Number(e.target.value))
            }
            className="form-input"
            onKeyDown={(e) => {
              if (e.key === "Enter") e.preventDefault();
            }}
          />
        </label>
        <div className="chapter-selector">
          <select
            value={activeChapter}
            onChange={(e) => setExactChapter(Number(e.target.value))}
            className="form-select"
          >
            {chapters.map((item, index) => (
              <option key={index} value={item.chapterNumber}>
                Chapter {item.chapterNumber}
              </option>
            ))}
          </select>
        </div>
        {activeChapterContent && (
          <div className="chapter-questions">
            <h3>Chapter {activeChapterContent.chapterNumber}</h3>
            {activeChapterContent.questions.map((question, questionIndex) => (
              <div key={questionIndex} className="question-item">
                <label>
                  Question {questionIndex + 1}:
                  <input
                    type="text"
                    value={question}
                    onChange={(e) =>
                      handleChapterQuestionChange(
                        activeChapter - 1,
                        e.target.value,
                        questionIndex
                      )
                    }
                    placeholder="Example"
                    className="form-input"
                  />
                </label>
                <label>
                  Answer:
                  <input
                    type="text"
                    value={activeChapterContent?.answers[questionIndex]}
                    onChange={(e) =>
                      handleChapterAnswerChange(
                        activeChapter - 1,
                        e.target.value,
                        questionIndex
                      )
                    }
                    placeholder="Example"
                    className="form-input"
                  />
                </label>
                <button
                  type="button"
                  onClick={() =>
                    deleteQuestion(activeChapter - 1, questionIndex)
                  }
                  className="delete-question"
                >
                  X
                </button>
              </div>
            ))}
            <button
              type="button"
              onClick={() => addQuestionToChapter(activeChapter - 1)}
              className="add-question"
            >
              Add Question
            </button>
          </div>
        )}
        <button type="submit" className="save-button">
          Save
        </button>
      </form>
    </div>
  );
};

export default AddBooksForm;
